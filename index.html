<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Faiz Ansari - Developer</title>

	<style type="text/css">
		html, body {
			background-color: black;
			font-family: 'Avenir Next','Segoe ui',sans-serif;
			height: 100%;
			margin: 0;
		}

        #canvas-container {
            position: fixed;
        }

		main {
			display: flex;
			position: absolute;
			flex-direction: column;
			width: 240px;
			margin: 1em;
			padding: 1em;
			z-index: 1;
			background-color: rgba(0,0,0,0.8);
			border-radius: 1em;
		}

		h1 {
			margin-top: 0;
			margin-bottom: 1.5rem;
			color: white;
			font-size: 27px;
			font-weight: normal;
			letter-spacing: 1px;
		}

		a {
			height: 40px;
			margin-bottom: 1rem;
			color: grey;
			border: 1px solid;
			border-radius: 4px;
			box-sizing: border-box;
			line-height: 40px;
			font-size: 15px;
			text-align: center;
			text-decoration: none;
			cursor: pointer;
			transition: color 120ms;
		}

		a:hover {
			color: white;
		}

		a:active {
			color: grey;
		}

		span {
			position: absolute;
			margin-top: 6em;
			margin-left: 1em;
			z-index: 0;
			white-space: nowrap;
			color: grey;
			font-size: 40px;
			font-weight: bold;
			letter-spacing: 1px;
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}

	</style>
</head>
<body>
	<div id="canvas-container"></div>
	<main>
		<h1>Faiz Ansari</h1>
		<a href="https://github.com/fezimsorry" target="_blank">a sparsely used <strong>GitHub</strong></a>
		<a href="https://www.imdb.com/name/nm11636236/" target="_blank"><strong>IMDb</strong> show credits</a>
	</main>
	<span>//work in progress</span>	
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Select the canvas container
        const container = document.getElementById('canvas-container');

        // Initialize the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement); // Attach canvas to the container

        // Create materials for the helix strands (red, white, green)
        const redMaterial = new THREE.MeshBasicMaterial({ color: 0xEE2A35 });
        const whiteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const greenMaterial = new THREE.MeshBasicMaterial({ color: 0x009736 });

        // Create a parent object to hold the helix and apply the z-axis rotation
        const helixGroup = new THREE.Object3D(); // Parent object for the helix
        const rotationGroup = new THREE.Object3D(); // Object for visual rotation
        scene.add(rotationGroup);
        rotationGroup.add(helixGroup); // Rotate this for the 30-degree effect

        // Parameters for the helix
        const helixRadius = 1;
        const helixHeight = 0.2;
        const numPoints = 100; // Points per strand
        const helixSpacing = 0.15; // Spacing between helix loops

        // Function to create a sphere at a given position
        function createSphere(material, x, y, z) {
            const geometry = new THREE.SphereGeometry(0.05, 32, 32);
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            helixGroup.add(sphere); // Add sphere to the helix group
        }

        // Function to create the triple helix
        function createHelix() {
            for (let i = 0; i < numPoints; i++) {
                const angle = i * 0.2; // Angle to control rotation of the helix
                const y = i * helixSpacing - 1.5; // Move up along the Y-axis

                // Calculate positions for the three strands
                const x1 = helixRadius * Math.cos(angle); // Red strand
                const z1 = helixRadius * Math.sin(angle);

                const x2 = helixRadius * Math.cos(angle + Math.PI * 2 / 3); // White strand
                const z2 = helixRadius * Math.sin(angle + Math.PI * 2 / 3);

                const x3 = helixRadius * Math.cos(angle + (Math.PI * 4) / 3); // Green strand
                const z3 = helixRadius * Math.sin(angle + (Math.PI * 4) / 3);

                // Create spheres for each position in the triple helix
                createSphere(redMaterial, x1, y, z1);
                createSphere(whiteMaterial, x2, y, z2);
                createSphere(greenMaterial, x3, y, z3);
            }
        }

        // Call the function to generate the helix
        createHelix();

        // Position the camera to look at the helix perpendicularly
        camera.position.x = 0;
        camera.position.y = 5;
        camera.position.z = 11;
		
        // Apply the 30-degree clockwise rotation around the z-axis to the rotation group
        rotationGroup.rotation.z = -THREE.MathUtils.degToRad(20);
		rotationGroup.rotation.y = -THREE.MathUtils.degToRad(20);

		// Function to dynamically update translation based on viewport width
		function updateTranslation() {
            const vw = window.innerWidth;
            const translation = -0.40 * vw; // Translate by -40vw

            // Adjust the camera's lookAt x-value based on the translation
            camera.lookAt(-translation / 70, 5, translation / 100);
        }

        // Rotation animation for the helix around its own y-axis
        function animate() {
            requestAnimationFrame(animate);
            helixGroup.rotation.y += 0.01; // Rotate the helix group around its own Y-axis
            renderer.render(scene, camera);
        }

        // Start the animation loop
        animate();

        // Adjust canvas size on window resize
        window.addEventListener('resize', function() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
			updateTranslation();
        });

		updateTranslation();

    </script>
</body>

</html>
